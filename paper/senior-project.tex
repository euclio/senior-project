\documentclass[finalcopy]{srpaper}

\usepackage[toc,page]{appendix}
\usepackage{booktabs}
\usepackage{etoolbox}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mdframed}
\usepackage[outputdir=latexmk]{minted}
\usepackage{longtable}
\usepackage{ltablex}
\usepackage{url}
\usepackage{verbatimbox}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted{bgcolor=bg}
\lstset{basicstyle=\scriptsize}

\title{Rust vs. D:\ Exploring the Possible Successors of C++}
\author{Andy Russell}
\date{\today}
\advisor{Professor Kim Bruce}

\abstract{The programming languages D and Rust aim to simplify the complex and
error-prone features of C++ while maintaining a similar level of performance.
This paper examines whether the languages succeed in easing the development of
safe code, with a particular focus on each language's compile-time features and
memory management techniques. C++, D, and Rust are evaluated on both subjective
and empirical criteria. In order to evaluate the success of each language's
design goals, I have implemented a number of small programs that demonstrate
common tasks in systems programming, each in C++, D, and Rust. I recruited a
number of volunteers with prior experience with C++ to attempt the
implementation of these programs in D or Rust as well. Each volunteer
documented his or her development process in detail, particularly noting any
errors or bugs that were encountered. The programmers tallied and categorized
each error. This data was used to analyze whether a particular language makes
it easier to avoid certain errors. I then evaluated each language on
expressiveness and ease of development to determine whether the language's
design goals have been met.}

\acknowledgment{The author is deeply thankful to Professor Kim Bruce for his
help through every step of writing this document. He is grateful to Sam Posner
and Andrew Fishberg as well for their inputs on determining the set of programs
for the study. Additional thanks go to the volunteers who dedicated their time
and effort.}

\begin{document}
\frontmatter

\addcontentsline{toc}{section}{List of Listings}
\listoflistings{}

\chapter{Introduction}

Systems programming is an extremely important part of computing today. The raw
speed and low-level access to hardware provided by systems programming
languages are necessary for embedded systems, networking, and gaming, plus any
number of other applications. However, such command of a computer's hardware
naturally invites danger\footnote{Throughout this paper, when I refer to a
concept or feature as ``dangerous,'' I mean that it is error-prone or difficult
to reason about, especially if the errors that may arise from its use are
resistant to debugging.}.

Mistakes in managing memory can lead to run-time crashes or security
vulnerabilities such as buffer overflow or format string
attacks~\cite{Shahriar:2012:MPS:2187671.2187673}. While there are many tools
designed to allow programmers to catch such errors, the ideal solution would be
to eliminate the burden of manual memory management altogether. Other languages
such as Java and C\#, inspired by this goal, have removed that need. However,
due to their dependence on a virtual machine, they have sacrificed performance
and the ability to interface directly with
hardware~\cite{Alexandrescu:2010:DPL:1875434}. The languages examined in this
paper, D and Rust, do not use a virtual machine, instead opting for native
compilation. The languages aim to match the low-level speed and power of C++
while attempting to make code easier to write both from an expressiveness and
correctness standpoint.

This paper aims to analyze the Rust and D programming languages from as
objective a standpoint as possible. I primarily focus on the features that each
language makes at compile time, with memory-safety and preprocessing feature
taking a particular emphasis, due to the misuse of these features causing
dangerous errors in C++.

\chapter{Background}

In order to adequately discuss the design decisions that the implementors of
Rust and D have made, it is important to determine a context from which we can
compare them. Since both languages aim to occupy the same space as C++, I have
decided to compare the languages using C++ as a reference point. In addition
to considering the historical context that each language developed in, I have
decided to focus on a few important features that are essential to systems
programming.

\section{History}

Though C++, D, and Rust are all related, the languages developed within
different historical contexts.

C++ was developed in the early '80s by Bjarne Stroustrup. Stroustrup wished to
bring high-level features such as classes, strong typing, and default arguments
to C. It attempts to provide the programmer with a one-to-one mapping of
built-in types to the hardware, while also offering flexible abstractions to
allow user-defined types to take advantage of the same facilities available to
the built-ins. Stroustrup himself outlined the design philosophy of C++ in two
points:

\begin{itemize}
\item \textit{Leave no room for a lower-level language below C++}
\item \textit{What you don't use you don't pay for}. This is also known as the
``zero-overhead principle''.
\end{itemize}

These principles serve to keep C++ close to its roots in C while maintaining
the abstractions that make it a high-level language~\cite{stroustrup2013the}.
C++ remains one of the most popular languages in the world.

D was created in 2001 by Walter Bright, and later developed by Digital
Mars~\cite{Doverview}. As the name indicates, D has drawn much inspiration from
C++, as C++ did from C. However, D has made a number of backwards-incompatible
changes from C++ in the process of achieving its design goals. The D website
cites a number of reasons why D is necessary. Most relevant to this paper are
its assertions about the inherent complexity in C++ due to the sheer number of
features present in the language, the burden of explicit memory management, the
difficulty in tracking down pointer bugs, and the hindrance of backwards
compatibility with C~\cite{Doverview}. D, while less popular than C++,
maintains a healthy online presence and is often promoted by C++ gurus such as
Andrei Alexandrescu.

Rust is a quite new programming language developed primarily by Mozilla
starting in 2012. Rust aims to give programmers enough power to access the
computer's hardware while providing ``strong guarantees about isolation,
concurrency, and memory safety''~\cite{Matsakis:2014:RL:2663171.2663188}.
Syntactically, Rust is a more radical departure from C++ than D. However, it
has similar design goals. Despite not having a stable release, Rust generates a
considerable amount of discussion and written code, as evidenced by the over
one million downloads served by \url{crates.io}, Rust's package hosting
website~\cite{Cratesio}.

\section{Preprocessing, Macros, and Conditional Compilation}

The C++ macro preprocessor is an integral part of the language. Perhaps the
most common use of the feature is to \texttt{include} one file (the ``header'')
within another. By defining the interface in the header, the implementation is
kept inside a single source file, and any number of other source files may use
the interface's implementation. While the macro preprocessor is a necessary
part of the language, it is inherently dangerous. The preprocessor works by
modifying the actual text of the program, which can lead to syntax errors or
subtle bugs that are difficult to solve. Another use of the preprocessor is
for conditional compilation, where different code should be compiled depending
on various conditions such as the underlying architecture or character-encoding
support. Stroustrup advises that the C++ preprocessor should only be used for
these cases~\cite{stroustrup2013the}.

% TODO: Provide examples

D provides safer alternatives to the C++ preprocessor, and, when possible,
obviates its need entirely. For example, inclusion is handled by modules, which
handle imports of symbols from other files. This also removes the need for
include guards, because each symbol is only guaranteed to be imported once.
Conditional compilation is achieved through the \texttt{version} keyword. D
also contains an aggressive inliner, which removes the need to implement small
functions as macros~\cite{pretod}.

In lieu of the preprocessor, Rust has an extremely powerful macro system.
Rust macros operate on the abstract syntax tree of the program, rather than on
the text. This allows macros to be type-safe and extend the language itself.
In Rust, \texttt{println} is a macro that performs type-checking on its
arguments to ensure that the format string contains the proper number of
format placeholders for the arguments. In other languages, it might be
possible to check this with a special code path in the compiler, but in Rust
the language itself does the checking.

\section{Memory Management}

Memory management is a key component of systems languages. Many
performance-critical applications depend on the power of being able to manage
memory manually. However, this opens up an entire class of bugs. Some of these
bugs include memory leaks (forgetting to free allocated memory) and
use-after-free (using a pointer to memory that has already been reclaimed by
the memory manager). These bugs are often difficult to track down.

C++'s memory management works similarly to its ancestor, C. In fact, due to to
its commitment to backwards compatibility, C++ even inherits the
\texttt{malloc()} and \texttt{free()} functions, as seen in
Listing~\ref{lst:cmemory}. These functions allow the programmer to request and
return blocks of memory to the free store, or heap. However, C++ programmers
should never use these functions, instead opting for the \texttt{new} and
\texttt{delete} operators. C++ has additional operators for array allocation:
\texttt{new[]} and \texttt{delete[]}. Listing~\ref{lst:cppmemory} uses the
operators to allocate an array. These keywords are slightly safer because the
programmer no longer has to keep track of the exact size of the allocation, the
programmer must still remember to to \texttt{delete} all memory acquired by
\texttt{new} to avoid memory leaks, and refrain from using deallocated or
unallocated memory to prevent invoking undefined
behavior~\cite{stroustrup2013the}. In addition, the correct form of the keyword
must be used, as using the non-array \texttt{delete} may leave the heap in an
inconsistent state.

\begin{listing}[H]
\begin{minted}{c}
/* Allocates 10 elements on the heap. */
int* elements = malloc(sizeof(int) * 10);

/* ... */

/* Release the memory for reuse. */
free(elements);
\end{minted}
\caption{C memory management.}
\label{lst:cmemory}
\end{listing}

\begin{listing}[H]
\begin{minted}{c++}
// Allocates 10 elements on the heap.
int[] elements = new int[10];

// ...

// Release the memory for reuse.
delete[] elements;      // Don't forget the `[]'!
\end{minted}
\caption{Primitive C++ memory management.}
\label{lst:cppmemory}
\end{listing}

Undefined behavior is
characterized by the \textit{lack} of a definition of what an implementation of
C++ should do in a given situation~\cite{iso/iec}. In other words, if a program
incurs undefined behavior, then an implementation is in no way required to act
in any particular way. The program may not compile, may crash at run-time, or
act in any number of ways. Clearly it is impossible to reason about the
correctness of a program that causes undefined behavior, so C++ programmers
must avoid it at all costs.

\begin{listing}
\begin{minted}{c++}
#include <array>
#include <memory>

// Allocates 10 elements on the heap.
std::unique_ptr<int[]> elementsPtr(new int[10]);
// Using std::array avoids explicitly using `new'.
std::array<int, 10> elementsArray;

// ...

// Memory is freed when the unique_ptr and array go out of
// scope.
\end{minted}
\label{lst:cppmodernmemory}
\caption{Modern C++ memory management.}
\end{listing}

C++ programmers are well-aware of the problems that arise from using
\texttt{new} and \texttt{delete} improperly. In fact, Stroustrup warns that
``naked \texttt{new}'' (using \texttt{new} to allocate an object directly)
ought to be avoided. Instead, he advises programmers to use stack-based
allocation when possible, and in other cases use manager objects such as
\texttt{unique\_ptr} and \texttt{shared\_ptr}\footnote{These containers were
    introduced in C++11.}. This idiom is known as ``Resource Acquisition Is
Initialization'', or RAII~\cite{stroustrup2013the}. These containers help
abstract memory management away from the programmer by ensuring \texttt{delete}
is called when the pointer goes out of scope.

D's creators acknowledged the problems with manual memory management and opted
to remove the need for it entirely. D handles memory management through a
garbage collector. D classes are automatically allocated on the heap, and all
other data is created on the stack. The garbage collector frees any memory that
has gone out of scope (though not necessarily immediately after). This removes
the need for the programmer to explicitly allocate and deallocate memory. Like
C++, destructors are executed when variables go out of scope, allowing RAII
behavior. In addition, D provides the ``Scope Guard'' statement, which offers
more fine-grained control over when scope-dependent blocks of code should
execute, seen in Listing~\ref{lst:dscope}. For example, if an exception is
thrown, the code would print \texttt{success} and then \texttt{exited} on their
own lines. If an exception was thrown, the code would print \texttt{failure},
then \texttt{exited}.

\begin{listing}[H]
\begin{minted}{d}
import std.stdio;

try {
    scope(exit) writeln("exited");
    scope(failure) writeln("failure");
    scope(success) writeln("success");
    // Code that may throw an exception...
} catch (Exception e) {}
\end{minted}
\caption{D scope guards.}
\label{lst:dscope}
\end{listing}

D programmers may also opt-out of the garbage collector by marking functions
with the \texttt{@nogc} attribute. Within \texttt{@nogc} functions, the garbage
collector will not run. This feature is intended for situations where the
overhead introduced by the D runtime (which contains the garbage collector) is
unacceptable, such as when implementing a kernel or in performance-critical
applications. However, this introduces a number of problems, as allocating
classes and other types that rely on GC allocation will be no longer possible.
In addition, some parts of the standard library perform heap allocations,
though the goal is to eventually mark all of D's standard library as
\texttt{@nogc}.

Rust, on the other hand, attempts to find a middle ground between the
performance of C++ and the overhead of D. One of the interesting features of
Rust is its guarantees about heap access. It accomplishes this by strictly
enforcing the concept of ownership. Ownership can be seen in C++ by looking at
the names of its pointer types\footnote{That is, \texttt{unique\_ptr},
\texttt{shared\_ptr}, or \texttt{weak\_ptr}}. For example, a
\texttt{unique\_ptr} only allows itself \texttt{unique\_ptr} to point at its
memory. It enforces this by disallowing copying and requiring that reassignment
be done through a move, which transfers ownership of a piece of memory from one
object or scope to another. However, ownership transfer may introduce bugs, as
shown in Listing~\ref{lst:cppuseaftermove}.

Rust avoids this class of bug entirely by guaranteeing at compile time that
moved memory cannot be used. Attempting to compile
Listing~\ref{lst:rustuseaftermove} would result in \texttt{error: use of moved
value: `x`}. Even more powerful than this is that Rust guarantees that ``no
other writable pointers alias to this heap memory'', meaning that it is
impossible for multiple objects to write to the same memory location (unless
the programmer were to use an \texttt{Rc} pointer, which allows multiple
readers and writers through reference counting)~\cite{RustPointerGuide}.

\begin{listing}[h]
\begin{minted}{cpp}
#include <memory>
#include <iostream>

// Allocate an int on the heap
std::unique_ptr<int> movedPtr(new int(10));

// Change the int's owner to a new pointer.
std::unique_ptr<int> ptr = std::move(ptr);

// Attempt to dereference the pointers.
std::cout << *ptr << std::endl;
std::cout << *movedPtr << std::endl;    // Segfault!
\end{minted}
\caption{C++ use of moved value (bug).}
\label{lst:cppuseaftermove}
\end{listing}

\begin{listing}[h]
\begin{minted}{rust}
let x = Box::new(5i);       // Allocate an int on the heap.
let y = x;                  // Change the int's owner to y.
println!("{}", x);          // error: use of moved value: 'x'
\end{minted}
\caption{Rust use of moved value (compilation error).}
\label{lst:rustuseaftermove}
\end{listing}

\chapter{Evaluation Strategy}

\section{Criteria}

One of the most challenging aspects of evaluating languages is deciding the
criteria on which they are evaluated. In order to obtain as comprehensive an
evaluation of Rust and D as possible, I wish to include both qualitative and
quantitative criteria.

AlGhamdi and Urban provide an excellent list of qualitative methodologies on
which I have based my own methodology~\cite{AlGhamdi:1993:CAP:162754.162876}.
Their paper summarizes twelve methodologies, and the factors that may be used
to achieve an apt comparison. The following list summarizes the methodologies
expounded in their paper that I will employ in my project.

\begin{enumerate}
\item Comparison of Philosophy and History

Since both Rust and D occupy a similar domain, the main factor that I will use
to distinguish the two is the ``intention of [the] designers''. While these
languages were created nearly a decade apart, differ in their corporate
affiliations, and have varying development team size, I find these factors less
relevant for my study. I believe that the only factor that deeply affects
programmers using the languages is the design philosophy behind them.

\item The Degree of Permissiveness of the Language

This methodology includes criteria such as the ability of the programmer to
circumvent type-checking, operator overloading, and run-time checking. I am
particularly interested in the memory safety of Rust and D compared to C++.
While these languages will allow a programmer to circumvent the type system or
perform unsafe memory accesses, such practices are discouraged. So, I am
interested in the effectiveness of each language in avoiding the requirement of
such unsafe techniques.

\item Language Contributions to Program Readability

It is often said that code is read far more than it is written. In large
systems that depend on reliability, this is surely true. It follows that if
code is easier to read, it is easier to locate defects or bugs.

\item Language Contributions to Program Reliability

This is perhaps the most important methodology to my project. I am particularly
interested in examining how Rust and D attempt to avoid the common pitfalls
that plague C++ development. These include but are not limited to uninitialized
variables, null pointers, and memory leaks.

\item Data Structuring Facilities

This methodology is also quite important to my study. Rust and D are both
strongly typed, and each language provides a number of ways to inform the
compiler of programmer intent for the usage of various data types. Exploring
the numerous primitive data types, and the ability to construct new types from
those primitives is integral to understanding the power of each language.

\item Control Facilities

I am particularly interested in procedural-level control facilities. This
includes parameter-passing methods, concurrency, and generics/templates.

\item Language Contributions to Program Cost

This methodology explores the various costs involved with writing in a language
under consideration. This involves the cost of learning the language, the cost
of writing a program in the language, and even the cost of compiling a program.
The cost of executing and maintaining a program less relevant to this paper,
but I imagine the maintainence cost is somewhat encompassed by the criteria for
evaluating the languages' readability. While this methodology is particularly
important for new programmers, and becomes less apparent with experience, it is
nonetheless important to consider.

\end{enumerate}

In contrast to the methodologies listed above, I found a number of
methodologies irrelevant. For example, D and Rust appear almost identical in
terms of modularity (``Language Contributions to Program Modularity''),
portability (``Portability of a Language''), I/O facilities (``Input/Output''),
and support for inline assembly and foreign functions (``Escape from a
Language''). These methodologies either contribute little to my goal of
studying the memory safety of Rust and D, or the features provided by each
language are so similar that there is little comparison to be made between the
two.

\section{Experimental Design}

While I believe that the aforementioned methodologies comprise a satisfactory
qualitative evaluation strategy for Rust and D, I do not believe that a full
comparison can be achieved with these methodologies alone. Furthermore, many of
the criteria are rather subjective. For my project, I have strived to develop a
method which can be used to compare various language features while avoiding
subjectivity or bias.

Originally, I planned to come up with a number of programs that embodied the
core of systems programming, and then develop these programs in C++, D, and
Rust. Then, using my own experiences, I would attempt to evaluate the
effectiveness of each language for developing these programs. However, this
approach is flawed in a number of ways. For example, suppose I had attempted to
implement a program with logic that required a large amount of conditionals in
Rust. I would likely have encountered a number of bugs with my initial
implementation but eventually have come up with a satisfactory result. Then,
upon moving onto D, I would have avoided most of the errors that I encountered
while working on the Rust implementation. My development process in D would
likely have felt more natural, and the code would probably look eerily like
Rust. To mitigate this problem, I instead recruited a number of volunteers to
learn each language individually, and implement a series of programs meant to
demonstrate various features that are important to systems languages.

I advertised my study both on the Computer Science Facebook group and through
Computer Science colloquium. Once volunteers indicated their interest, I sent
them a document\footnote{The document itself may be found in
Appendix~\ref{app:resources}.}. detailing my expectations for the project. The
volunteers then sent me information including their name, major, experience
with programming, and a confirmation that they read the document in its
entirety.

Each volunteer was then assigned either Rust or D as a language. I tried to
satisfy the volunteer's preference for learning the language, though I first
ensured that the experience level between each language would be comparable.
Over the next month, each volunteer was expected to attempt to implement one
of five programs. The volunteers were not expected to spend more than 2 hours
on each program, but most volunteers worked on each program to completion.

The programs implemented by the volunteers were designed to cover an
assortment of language features as well as to highlight common bugs. The
programs were as follows:

\begin{enumerate}

\item Sentence Splitter

Volunteers were asked to implement a single string into sentences using a set
of heuristics. The difficulty of this program stems from the fact that
while sentences are delimited by periods, question marks, and exclamation
points, they may also include websites, titles, and abbreviations, all of
which are \textit{not} boundaries.

This program was meant to introduce the programmers to string manipulation
techniques and required a large amount of logical branching.

\item Integer Linked List

The next program was to implement a simple linked list data structure that
operates on integers. A number of operations were required to be supported,
including insertion, deletion, retrieval, and methods to query the size, head
and tail of the list.

This program introduced the volunteers to object-orientation, pointer
manipulation, and memory allocation.

\item Generic Array List

The next program involved creating an array list that supported generic
elements. The array list was required to support the same operations as the
integer linked list, and covered the same features of the languages.

\item Parallel Mergesort

Volunteers were then asked to implement the parallel mergesort algorithm. This
algorithm is relatively simple to understand, and easily parallelizable.

This program introduced the programmers to recursion and concurrency.

\item Brainfuck Interpreter

Lastly, the programmers were asked to implement a Brainfuck interpreter.
Brainfuck is an esoteric programming language, known for being fiendishly
unreadable. However, the language's semantics are quite easy to understand. In
short, there are eight meaningful characters in the language, all of which
either manipulate the ``data pointer'' in some way (by incrementing,
decrementing, etc.), or perform I/O on the byte pointed at by the pointer.

This program served as a kind of ``capstone'' for the study. It is larger than
the other programs, and involves file I/O and pointer manipulation.

\end{enumerate}

Each volunteer was also required to document their development process. While
developing each program, the volunteer would note every error encountered,
categorize it as a syntax error, logic error, or resource error, and whether
the error was caught at compile-time or run-time.

\chapter{Results}

Given Rust's focus on compile-time error catching and D's focus on ease of
use, I hypothesized that my volunteers would encounter a much greater number
of compile time issues with Rust, and that D programmers would find that their
programs ran into more runtime issues. Also, D's syntax would be more familiar
to my volunteers. I found that my hypothesis was true.

\section{Experimental Results}

I was able to recruit seven volunteers that generously donated their time and
effort to my project. Each volunteer was very experienced in programming: six
were computer science majors, and one was a computer science minor.
Figure~\ref{fig:sampleerrorlog} contains a snippet of an error log submitted
by one of my volunteers.

\begin{figure}[h]
\begin{lstlisting}[breaklines]
Syntax error - Wrong syntax of println - Compile time
Syntax error - Wrote "splitSentences" instead of "split_sentences" - Compile time
Syntax error - Used old variable name - Compile time
Syntax error - Tried to iterate over len() instead of range(0, len()) - Compile time
Syntax error - Used one argument instead of two with range() - Compile time
Syntax error - Passed char instead of &char in the contains func - Compile time
Syntax error - Used [char] instead of &[char] in initialization of array - Compile time
\end{lstlisting}
\caption{Sample error log}
\label{fig:sampleerrorlog}
\end{figure}

All of my volunteers were able to complete the sentence splitter. It was very
interesting to see the types of errors that were encountered during this phase
of the experiment. As expected, Rust programmers found many more compile time
issues. Surprisingly, D programmers ran into segmentation faults due to the
behavior of attempting to access iterators out of bounds.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
A (D) & 6 & 2 & 0 & Blah \\
B (Rust) & 6 & 0 & 0 & Did not finish \\
C (D) & 8 & 2 & 0 & Passes test suite \\
D (D) & 2 & 1 & 0 & Infinite loop on ellipsis \\
E (Rust) & 18 & 5 & 0 & Passes test suite \\
F (Rust) & 15 & 0 & 0 & Passes test suite \\
G (D) & 4 & 2 & 0 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Sentence splitter error log summary}
\label{tab:sentencesplitter}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
B (Rust) & 10 & 0 & 0 & Did not finish \\
C (D) & 9 & 0 & 1 & Passes test suite \\
D (D) & 1 & 0 & 3 & Segfault on \texttt{remove()} \\
G (D) & 6 & 1 & 2 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Integer linked list error log summary}
\label{tab:intlinkedlist}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
B (Rust) & & & & \\
D (D) & 2 & 0 & 0 & Passes test suite \\
G (D) & 4 & 0 & 0 & Passes, \texttt{head()} and \texttt{tail()} not implemented \\
\bottomrule
\end{tabular}
\caption{Generic array list error log summary}
\label{tab:genericarraylist}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
B (Rust) & & & & \\
D (D) & 3 & 1 & 0 & Passes test suite \\
G (D) & 3 & 2 & 0 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Parallel mergesort error log summary}
\label{tab:parallelmergesort}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
D (D) & 9 & 0 & 0 & Segmentation fault \\
G (D) & 4 & 1 & 0 & Fails test suite \\
\bottomrule
\end{tabular}
\caption{Brainfuck interpreter error log summary}
\label{tab:brainfuckinterpreter}
\end{table}

\section{Evaluation}

\chapter{Conclusion}

\nocite{*}
\bibliography{senior-project}

\appendix
\chapter{Volunteer Resources}\label{app:resources}
The following documents were sent to the volunteers of my project. The
documents contain explanations of the project expectations, brief descriptions
of the programs to be implemented, and installation instructions for the
languages themselves.

The documents were written using Markdown. The versions included in this
appendix are rendered from \LaTeX{} generated from the Markdown source. The
documents appear online at
\url{https://github.com/euclio/senior-project/tree/master/resources}.

\clearpage
\input{../resources/project_agreement.tex}
\clearpage
\input{../resources/d_resources.tex}
\clearpage
\input{../resources/rust_resources.tex}

\chapter{Solutions}\label{app:solutions}
This appendix includes my solutions to the problems that were given to my
volunteers. The code in each example strives to be as idiomatic as possible in
each language.

\setminted{bgcolor=}

\section{Hello, World}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted{cpp}{../examples/hello-world/hello_world.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted{d}{../examples/hello-world/hello_world.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted{rust}{../examples/hello-world/hello_world.rs}
\end{mdframed}

\section{Sentence Splitter}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/sentence-splitter/sentence_splitter.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/sentence-splitter/sentence_splitter.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/sentence-splitter/sentence_splitter.rs}
\end{mdframed}

\section{Integer Linked List}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/int-linked-list/int_linked_list.hpp}
\end{mdframed}

\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/int-linked-list/int_linked_list.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/int-linked-list/int_linked_list.d}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/int-linked-list/tests/int-linked-list-test.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/int-linked-list/int_linked_list.rs}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/int-linked-list/tests/int-linked-list-test.rs}
\end{mdframed}

\section{Generic Array List}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/generic-array-list/generic_array_list.hpp}
\end{mdframed}

\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/generic-array-list/generic_array_list.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/generic-array-list/generic_array_list.d}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/generic-array-list/tests/generic_array_list_test.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/generic-array-list/generic_array_list.rs}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/generic-array-list/tests/generic-array-list-test.rs}
\end{mdframed}

\section{Parallel Merge Sort}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/parallel-merge-sort/parallel_merge_sort.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/parallel-merge-sort/parallel_merge_sort.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/parallel-merge-sort/parallel_merge_sort.rs}
\end{mdframed}

\section{Brainfuck Interpreter}

\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/brainfsck/brainfsck.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/brainfsck/brainfsck.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/brainfsck/brainfsck.rs}
\end{mdframed}

\subsection{Brainfuck Test Case (``Hello World'')}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{brainfuck}{../examples/brainfsck/tests/hello.bf}
\end{mdframed}

\end{document}
