\documentclass[finalcopy]{srpaper}

\usepackage[toc,page]{appendix}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{etoolbox}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mdframed}
\usepackage[outputdir=latexmk]{minted}
\usepackage{longtable}
\usepackage{ltablex}
\usepackage{url}
\usepackage{verbatimbox}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted{bgcolor=bg}
\lstset{basicstyle=\scriptsize}

\title{Rust vs. D:\ Exploring the Possible Successors of C++}
\author{Andy Russell}
\date{\today}
\advisor{Professor Kim Bruce}

\abstract{The programming languages D and Rust aim to simplify the complex and
error-prone features of C++ while maintaining a similar level of performance.
This paper examines whether the languages succeed in easing the development of
safe code, with a particular focus on each language's compile-time features and
memory management techniques. C++, D, and Rust are evaluated on both subjective
and empirical criteria. In order to evaluate the success of each language's
design goals, I have implemented a number of small programs that demonstrate
common tasks in systems programming, each in C++, D, and Rust. I recruited a
number of volunteers with prior experience with C++ to attempt the
implementation of these programs in D or Rust as well. Each volunteer
documented his or her development process in detail, particularly noting any
errors or bugs that were encountered. The programmers tallied and categorized
each error. This data was used to analyze whether a particular language makes
it easier to avoid certain errors. I then evaluated each language on
expressiveness and ease of development to determine whether the language's
design goals have been met.}

\acknowledgment{The author is deeply thankful to Professor Kim Bruce for his
help through every step of writing this document. He is grateful to Sam Posner
and Andrew Fishberg as well for their inputs on determining the set of programs
for the study. Additional thanks go to the volunteers who dedicated their time
and effort to the study. And lastly, a special thanks to the author's parents
for their unwavering support and advice in whatever his endeavors.}

\begin{document}
\frontmatter

\addcontentsline{toc}{section}{List of Listings}
\listoflistings{}

\chapter{Introduction}

Systems programming is an extremely important part of computing today. The raw
speed and low-level access to hardware provided by systems programming
languages are necessary for embedded systems, networking, and gaming, plus any
number of other applications. However, such command of a computer's hardware
naturally invites danger\footnote{Throughout this paper, when I refer to a
concept or feature as ``dangerous,'' I mean that it is error-prone or difficult
to reason about, especially if the errors that may arise from its use are
resistant to debugging.}.

Mistakes in managing memory can lead to run-time crashes or security
vulnerabilities such as buffer overflow or format string
attacks~\cite{Shahriar:2012:MPS:2187671.2187673,Seacord:2013:SCC:2530475}.
While there are many tools designed to allow programmers to catch such errors,
the ideal solution would be to eliminate the burden of manual memory management
altogether. Other languages such as Java and C\#, inspired by this goal, have
removed that need. However, due to their dependence on a virtual machine, they
have sacrificed performance and the ability to interface directly with
hardware~\cite{Alexandrescu:2010:DPL:1875434}. The languages examined in this
paper, D and Rust, do not use a virtual machine, instead opting for native
compilation. The languages aim to match the low-level speed and power of C++
while attempting to make code easier to write both from an expressiveness and
correctness standpoint.

This paper analyzes the Rust and D programming languages from as objective a
standpoint as possible. I primarily focus on the features that each language
makes at compile time, with memory-safety and preprocessing features taking a
particular emphasis, due to the misuse of these features causing dangerous
errors in C++.

\chapter{Background}\label{chap:background}

\epigraph{``D was conceived by people who were tired of how clunky C++ is. Rust
was conceived by peoples who were tired of how unsafe C++ is.''}{
\textit{User kibwen \\ Hacker News}}

In order to adequately discuss the design decisions that the implementors of
Rust and D have made, it is important to determine a context from which we can
compare them. Since both languages aim to occupy the same space as C++, I have
decided to compare the languages using C++ as a reference point. In addition to
considering the historical context that each language developed in, I focus on
a few important features that are essential to systems programming.

\section{History}

Though C++, D, and Rust are all related, the languages developed within
different historical contexts.

C++ was developed in the early '80s by Bjarne Stroustrup. Stroustrup wished to
bring high-level features such as classes, strong typing, and default arguments
to C. It attempts to provide the programmer with a one-to-one mapping of
built-in types to the hardware, while also offering flexible abstractions to
allow user-defined types to take advantage of the same facilities available to
the built-ins. Stroustrup himself outlined the design philosophy of C++ in two
points:

\begin{itemize}
\item \textit{Leave no room for a lower-level language below C++.}
\item \textit{What you don't use you don't pay for}. This is also known as the
``zero-overhead principle''.
\end{itemize}

These principles serve to keep C++ close to its roots in C while maintaining
the abstractions that make it a high-level language~\cite{stroustrup2013the}.
However, C++ is often criticized for its complicated and confusing behavior in
situations such function overload resolution~\cite{Dewhurst:2005:CCK:1050971}.
Despite its problems, C++ remains one of the most popular languages in the
world.

D was created in 2001 by Walter Bright, and later developed by Digital Mars, a
compiler development company~\cite{Doverview}. As the name indicates, D has
drawn much inspiration from C++, as C++ did from C. In Bright's own words, he
wished to design a language as ``it should be
done''~\cite{Alexandrescu:2010:DPL:1875434}. To this end, D has made a number
of backwards-incompatible changes from C++. The D website cites a number of
reasons why D is necessary. Most relevant to this paper are its assertions
about the inherent complexity in C++ due to the sheer number of features
present in the language, the burden of explicit memory management, the
difficulty in tracking down pointer bugs, and the hindrance of backwards
compatibility with C~\cite{Doverview}. D is often compared to C++: it is
commonly thought of as a ``better C++''~\cite{Alexandrescu:2010:DPL:1875434}.
While less popular than C++, D maintains a healthy online presence and is
promoted by C++ gurus such as Andrei
Alexandrescu and Scott Meyers ~\cite{Alexandrescu:2010:DPL:1875434}.

Rust is a quite new programming language developed primarily by Mozilla
starting in 2012. Rust aims to give programmers enough power to access the
computer's hardware while providing ``strong guarantees about isolation,
concurrency, and memory safety''~\cite{Matsakis:2014:RL:2663171.2663188}.
Syntactically, Rust is a more radical departure from C++ than D. However, it
has similar design goals. It aims to be used in such performance-critical
applications as operating systems and web browsers\footnote{Rust development is
driven in particular by the Servo Project
(\url{https://github.com/servo/servo}), an experimental web browser. Servo
requirements have inspired a number of Rust features.}. Despite
not having a stable release at the time of this writing, Rust generates a
considerable amount of discussion and written code, as evidenced by the over
one million downloads served by \url{crates.io}, Rust's package hosting
website~\cite{Cratesio}.

\section{Macros and Conditional Compilation}

Code generation is an extremely important feature of systems programming
languages. Because low-level code is very dependent on the underlying
hardware, different code must be generated for different platforms. Thus, C++,
D, and Rust all have their own methods for generating code at compile-time.

When compiling C++, code is first passed through the macro preprocessor, which
performs textual replacements and substitutions depending on the instructions
provided to the processor. These instructions are signaled by the presence of a
`\#' at the beginning of the line. Listing~\ref{lst:cpreproc} demonstrates a
simple preprocessor directive. Without the preprocessor, the code snippet would
fail to compile due to an undefined identifier \texttt{THREE}. The preprocessor
replaces all occurrences of \texttt{THREE} with the integer literal `3',
allowing the assertion to succeed~\cite{CppReference}.

\begin{listing}[H]
\begin{minted}{c}
#define THREE 3

assert(THREE == 3);
\end{minted}
\caption{The C macro preprocessor}
\label{lst:cpreproc}
\end{listing}

Another use of the preprocessor is to generate code that would be tedious to
write out by hand. The \texttt{max} function can be implemented as a macro that
expands \texttt{max(a, b)} to \texttt{a > b ?\ a :\ b}. A macro is advantageous
to a function because a function call introduces much more overhead than a
conditional. While this implementation works in many cases, consider the code
in Listing~\ref{lst:cmacrofail}. On first glance, one might expect the code to
return 2, as \texttt{x} is preincremented, making it greater than \texttt{y}.
The value would then be returned. Since macro expansion is simple textual
replacement, the expression is actually evaluated twice, meaning that the value
returned from \texttt{max} is actually 3~\cite{gnupreproc}. Such bugs are very
subtle and difficult to avoid.

\begin{listing}[H]
\begin{minted}{c}
#define max(A, B)  ((A) > (B) ? (A) : (B))

int x = 1;
int y = 1;

int max = max(++x, y);    // Uh oh...

// Expands to... (parentheses removed for clarity)
int max = ++x > y ? ++x : y;
\end{minted}
\caption{Macro side-effect evaluation (bug)}
\label{lst:cmacrofail}
\end{listing}

Despite this danger, the preprocessor is necessary to expose an interface of a
class or library by using the \texttt{\#include} directive to insert the
contents of one file (the ``header'') within another. The implementation is
kept inside a single source file, and any number of other source files may use
the interface's implementation. Listing~\ref{lst:header} contains a sample
header file\footnote{The data structures in Appendix~\ref{app:solutions} also
demonstrate the use of headers.}. This strategy works because C++ allows a
programmer to separate declaration from definition. The header file contains
declarations, which define the interface of a class or function. Another file
contains the definition, or implementation, of the interface. Because a symbol
must be defined and declared once, programmers must use ``include guards'' to
ensure this constraint holds. Include guards work by checking if a certain
preprocessor symbol is defined, which is usually based on the name of the file
being included. If the symbol is defined already, no text is included.
Otherwise, the symbol is defined to prevent subsequent inclusion and the text
of the header is included. A header file may be included multiple times as long
as there is only one definition. Since C++ does not support modules, this use
of the preprocessor is required to support multi-file programs.

\begin{listing}[H]
\begin{minted}{cpp}
#ifndef HEADER_HPP
#define HEADER_HPP

int foo(int a, int b);

#endif
\end{minted}
\begin{minted}{cpp}
#include "header.hpp"

int foo(int a, int b) {
    // ...
}
\end{minted}
\caption{C++ header file and definition}
\label{lst:header}
\end{listing}

The preprocessor is also necessary for conditional compilation, where different
code should be compiled depending on various conditions such as the underlying
architecture or character-encoding support. For example, the code in
Listing~\ref{lst:wincondition} will store different values in the \texttt{OS}
variable depending on whether the software was compiled on Windows or another
operating system.

\begin{listing}[H]
\begin{minted}{cpp}
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32)
static const std::string OS = "Windows";
#else
static const std::string OS = "Unix";
#endif
\end{minted}
\caption{Conditional compilation in C++}
\label{lst:wincondition}
\end{listing}

Achieving conditional compilation in this way is unfortunately an error-prone
practice. Consider the situation where there is a typo (such as a missing
double-quote) in the Windows branch, and compilation is attempted on Unix. The
compilation would succeed, because the compiler would never see the
Windows-specific branch of code after preprocessing. However, if compilation
were attempted on Windows, compilation would fail. Unfortunately, the C macro
preprocessor is the only way to obtain this result. Stroustrup advises
minimizing the use of the C++ preprocessor, and that it should only be used for
the specific cases of conditional compilation and header
files~\cite{stroustrup2013the}.

D provides safer alternatives to the C++ preprocessor. For example, inclusion
is handled by modules, which safely manage imports of symbols from other files,
as seen in the data structures in Appendix~\ref{app:solutions}. This also
removes the need for include guards, because each symbol is guaranteed to be
imported only once from a module by the compiler. The interface is inferred
from the function definitions in the module, so there is no need to copy the
interface, like the redundant function signature in Listing~\ref{lst:header}.

In D, conditional compilation is achieved through the \texttt{version}
keyword~\cite{Armaly:2007:DPL:1234292.1234301}. Listing~\ref{lst:dwincondition}
demonstrates how D would implement the same code as
Listing~\ref{lst:wincondition}. Since the \texttt{version} keyword is part of
the language grammar, syntax errors will be caught by the compiler regardless
of what compile path the program requires. D also contains an aggressive
inliner, which removes the need to implement small functions as
macros~\cite{pretod}. Instead, the compiler will directly insert the function
body into the caller's code, meaning that the compiled code has no function
call at all.

\begin{listing}[H]
\begin{minted}{d}
version (Windows) {
    static const string OS = "Windows";
} else {
    static const string OS = "Unix";
}
\end{minted}
\caption{Conditional compilation in D}
\label{lst:dwincondition}
\end{listing}

Like D, Rust also has a module system to handle inclusion and multi-file
compilation, so there is no need for a preprocessor. However, unlike D, Rust
has a macro system. Rust macros are far more powerful than C++ macros. Rust
macros operate on the abstract syntax tree of the program, rather than on the
text. This allows macros to be type-safe and extend the language itself. In
Rust, \texttt{println} is a macro that performs type-checking on its arguments
to ensure that the format string contains the proper number of format
placeholders for the arguments. In other languages, it might be possible to
check this with a special code path in the compiler, but in Rust the language
itself does the checking.

Rust also has a safer alternative for conditional compilation. In Rust, one can
write conditional code by applying attributes to arbitrary functions or
symbols, as seen in Listing~\ref{lst:rustwincondition}. Like D, since
configuration attributes are part of the language, there is no worry that
syntax errors will arise when compiling on different platforms.

\begin{listing}[H]
\begin{minted}{rust}
#[cfg(target_family = "windows")]
const OS: &'static str = "Windows";

#[cfg(target_family = "unix")]
const OS: &'static str = "Unix";
\end{minted}
\caption{Conditional compilation in Rust}
\label{lst:rustwincondition}
\end{listing}

\section{Memory Management}

Memory management is a key component of systems languages. Many
performance-critical applications depend on the power of being able to manage
memory manually. However, this opens up an entire class of bugs. Some of these
bugs include memory leaks (forgetting to free allocated memory) and
use-after-free (using a pointer to memory that has already been reclaimed by
the memory manager). These bugs are often difficult to track down.

In C++, all objects have a constructor and a destructor, which are functions
that allocate and deallocate any memory needed by the object respectively. If
the object is allocated on the stack, the constructor is run when the object
is created, and the destructor is run when the object goes out of scope (the
end of the innermost block). Stack memory is relatively easy to reason about,
but the programmer must be careful to avoid leaking a reference or pointer to
a stack-allocated variable outside of the scope where the variable was defined.
This could lead to undefined behavior.

Undefined behavior is characterized by the lack of a definition of what an
implementation of C++ should do in a given situation~\cite{iso/iec}. In other
words, if a program incurs undefined behavior, then an implementation is in no
way required to act in any particular way. The program may not compile, may
crash at run-time, or anything else. Clearly it is impossible to reason about
the correctness of a program that invokes undefined behavior, so C++ programmers
must avoid it at all costs.

C++'s heap memory management works similarly to its ancestor, C. In fact, due
to to its commitment to backwards compatibility, C++ even inherits the
\texttt{malloc()} and \texttt{free()} functions, as seen in
Listing~\ref{lst:cmemory}. These functions allow the programmer to request and
return blocks of memory to the free store, or heap. However, C++ programmers
should never use these functions, instead opting for the \texttt{new} and
\texttt{delete} operators, which ensure that the correct amount of memory is
allocated and deallocated and that constructors and destructors are run. C++
has additional operators for array allocation: \texttt{new[]} and
\texttt{delete[]}. Listing~\ref{lst:cppmemory} uses the operators to allocate
an array. These keywords are slightly safer than \texttt{malloc()} and
\texttt{free()} because the programmer no longer has to keep track of the exact
size of the allocation. However, the programmer must still remember to to
\texttt{delete} all memory acquired by \texttt{new} to avoid memory leaks, and
refrain from using deallocated or unallocated memory to prevent undefined
behavior~\cite{stroustrup2013the}. In addition, the correct form of the keyword
must be used, as using the non-array \texttt{delete} may leave the heap in an
inconsistent state.

\begin{listing}[H]
\begin{minted}{c}
/* Allocates 10 elements on the heap. */
int* elements = malloc(sizeof(int) * 10);

/* ... */

/* Release the memory for reuse. */
free(elements);
\end{minted}
\caption{C memory management}
\label{lst:cmemory}
\end{listing}

\begin{listing}[H]
\begin{minted}{c++}
// Allocates 10 elements on the heap.
int[] elements = new int[10];

// ...

// Release the memory for reuse.
delete[] elements;      // Don't forget the `[]'!
\end{minted}
\caption{Primitive C++ memory management}
\label{lst:cppmemory}
\end{listing}

\begin{listing}
\begin{minted}{c++}
#include <array>
#include <memory>

// Allocates 10 elements on the heap.
std::unique_ptr<int[]> elementsPtr(new int[10]);
// Using std::array avoids explicitly using `new'.
std::array<int, 10> elementsArray;

// ...

// Memory is freed when the unique_ptr and array go out of
// scope.
\end{minted}
\label{lst:cppmodernmemory}
\caption{Modern C++ memory management}
\end{listing}

C++ programmers are well-aware of the problems that arise from using
\texttt{new} and \texttt{delete} improperly. In fact, Stroustrup warns that
``naked \texttt{new}'' (using \texttt{new} to allocate an object directly)
ought to be avoided. Instead, he advises programmers to use stack-based
allocation when possible, and in other cases use manager objects such as
\texttt{unique\_ptr} and \texttt{shared\_ptr}\footnote{These containers were
introduced in C++11.}. This idiom is known as ``Resource Acquisition Is
Initialization'', or RAII~\cite{stroustrup2013the}. These containers help
abstract memory management away from the programmer by ensuring \texttt{delete}
is called when the pointer containers go out of scope by invoking the keyword
in their destructors.

D's creators acknowledged the problems with manual memory management and opted
to remove the need for it entirely. D handles memory management through a
garbage collector. D classes are automatically allocated on the heap, and all
other data is created on the stack. The garbage collector frees any memory that
has gone out of scope (though not necessarily immediately after). This removes
the need for the programmer to explicitly allocate and deallocate memory
through \texttt{new} and \texttt{delete}. Like C++, destructors are executed
when variables go out of scope, allowing RAII behavior. In addition, D provides
the ``Scope Guard'' statement, which offers more fine-grained control over when
scope-dependent blocks of code should execute, seen in
Listing~\ref{lst:dscope}. For example, if an exception is not thrown, the code
would print \texttt{success} and then \texttt{exited} on their own lines. If an
exception was thrown, the code would print \texttt{failure}, then
\texttt{exited}. A possible use of this feature would be to guarantee that
resources are closed properly when runtime exceptions are encountered.

\begin{listing}[H]
\begin{minted}{d}
import std.stdio;

try {
    scope(exit) writeln("exited");
    scope(failure) writeln("failure");
    scope(success) writeln("success");
    // Code that may throw an exception...
} catch (Exception e) {}
\end{minted}
\caption{D scope guards}
\label{lst:dscope}
\end{listing}

D programmers may also opt-out of the garbage collector by marking functions
with the \texttt{@nogc} attribute. Within \texttt{@nogc} functions, the garbage
collector will not run. This feature is intended for situations where the
overhead introduced by the D runtime (which contains the garbage collector) is
unacceptable, such as when implementing a kernel or in performance-critical
applications. However, this introduces a number of problems, as allocating
classes and other types that rely on the garbage will be no longer possible
without using the C++-like \texttt{new} and \texttt{delete} operators. These
operators bring the same problems that they had in C++, and D has no equivalent
to \texttt{unique\_ptr}, making their use arguably more dangerous in D. In
addition, some parts of the standard library perform heap allocations, making
it impossible to use these functions in some applications. The goal is to
eventually mark all of D's standard library as \texttt{@nogc}.

Rust, on the other hand, attempts to find a middle ground between the
memory-unsafe performance of C++ and the safer, but slower overhead of D. One
of the interesting features of Rust is its guarantees about heap access. One
could think of Rust as implicitly creating every variable as a C++-style
\texttt{unique\_ptr}. It accomplishes this by strictly enforcing the concept of
ownership through the type system and a ``borrow checker''. Ownership means
keeping track of which objects or functions ``own'' pieces of memory. For
example, passing a unique pointer to a function means that that function is
``borrowing'' the memory pointed to by the pointer. If we assume that the
caller owns the memory, then the function should return the memory to the
caller in a consistent state\footnote{That is, not deallocating or moving it.}.
Since C++11, it is possible to explicitly declare the programmer intent for the
owners of pointers. C++ pointer containers include \texttt{unique\_ptr},
\texttt{shared\_ptr}, or \texttt{weak\_ptr}. For example, a
\texttt{unique\_ptr} is the only owner of its memory. It enforces this by
disallowing copying and requiring that reassignment be done through a move,
which transfers ownership of a piece of memory from one object or scope to
another. Moves are far more efficient than copies, but they leave the previous
owner in an inconsistent state. This ownership transfer may introduce bugs, as
shown in Listing~\ref{lst:cppuseaftermove}.

\begin{listing}[h]
\begin{minted}{cpp}
#include <memory>
#include <iostream>

// Allocate an int on the heap
std::unique_ptr<int> movedPtr(new int(10));

// Change the int's owner to a new pointer.
std::unique_ptr<int> ptr = std::move(movedPtr);

// Attempt to dereference the pointers.
std::cout << *ptr << std::endl;
std::cout << *movedPtr << std::endl;    // Segfault!
\end{minted}
\caption{C++ use of moved value (bug)}
\label{lst:cppuseaftermove}
\end{listing}

Rust avoids this class of bug entirely by guaranteeing at compile time that
moved memory cannot be used. Attempting to compile
Listing~\ref{lst:rustuseaftermove} would result in \texttt{error: use of moved
value: `x`}. Even more powerful than this is that Rust guarantees that ``no
other writable pointers alias to this heap memory'', meaning that it is
impossible for multiple objects to write to the same memory location (unless
the programmer were to use an \texttt{Rc} pointer, which allows multiple
readers and writers through reference counting)~\cite{RustPointerGuide}.

\begin{listing}[h]
\begin{minted}{rust}
let x = Box::new(5i);       // Allocate an int on the heap.
let y = x;                  // Change the int's owner to y.
println!("{}", x);          // error: use of moved value: 'x'
\end{minted}
\caption{Rust use of moved value (compilation error)}
\label{lst:rustuseaftermove}
\end{listing}

\chapter{Evaluation Strategy}

\section{Criteria}

One of the most challenging aspects of evaluating languages is deciding the
criteria on which they are evaluated. In order to obtain as comprehensive an
evaluation of Rust and D as possible, I wish to include both qualitative and
quantitative criteria.

AlGhamdi and Urban provide an excellent list of qualitative methodologies on
which I have based my own methodology~\cite{AlGhamdi:1993:CAP:162754.162876}.
Their paper summarizes twelve methodologies, and the factors that may be used
to achieve an apt comparison. The following list summarizes the methodologies
expounded in their paper that I will employ in my project.

Other papers have attempted a feature-based
comparison~\cite{comparingFunctional}, with no evaluation. Still others have
performed such a comparison and then evaluated the features within different
domains~\cite{Feuer:1982:CPL:356869.356872}. I performed a feature-based
comparison in Chapter~\ref{chap:background}. I chose not to evaluate the
languages based on these features alone due to focusing on the general domain
of systems programming. Instead, my evaluation remains at a language-level
rather than feature-level.

\begin{enumerate}
\item Comparison of Philosophy and History

Since both Rust and D occupy a similar domain, the main factor that I will use
to distinguish the two is the ``intention of [the] designers''. While these
languages were created nearly a decade apart, differ in their corporate
affiliations, and have varying development team sizes, I find these factors less
relevant for my study. I believe that the only factor that deeply affects
programmers using D and Rust is the design philosophy behind the languages.

\item The Degree of Permissiveness of the Language

This methodology includes criteria such as the ability of the programmer to
circumvent type-checking, operator overloading, and run-time checking. I am
particularly interested in the memory safety of Rust and D compared to C++.
While these languages will allow a programmer to circumvent the type system or
perform unsafe memory accesses, such practices are discouraged. So, I am
interested in the effectiveness of each language in avoiding the requirement of
such unsafe techniques.

\item Language Contributions to Program Readability

It is often said that code is read far more than it is written. In large
systems that depend on reliability, this is surely true. It follows that if
code is easier to read, it is easier to locate defects or bugs.

\item Language Contributions to Program Reliability

This is perhaps the most important methodology to my project. I am particularly
interested in examining how Rust and D attempt to avoid the common pitfalls
that plague C++ development. These include but are not limited to uninitialized
variables, null pointers, and memory leaks.

\item Data Structuring Facilities

This methodology is also quite important to my study. Rust and D are both
strongly typed, and each language provides a number of ways to inform the
compiler of programmer intent for the usage of various data types. Exploring
the numerous primitive data types, and the ability to construct new types from
those primitives is integral to understanding the power of each language.

\item Control Facilities

I am interested in procedural-level control facilities. This includes
parameter-passing methods, concurrency, and generics/templates.

\item Language Contributions to Program Cost

This methodology explores the various costs involved with writing programs in a
language under consideration. This involves the cost of learning the language,
the cost of writing a program in the language, and even the cost of compiling a
program. The cost of executing and maintaining a program less relevant to this
paper, but I imagine the maintainence cost is somewhat encompassed by the
criteria for evaluating the languages' readability. While this methodology is
particularly important for new programmers, and becomes less apparent with
experience, it is nonetheless important to consider.

\end{enumerate}

In contrast to the methodologies listed above, I found a number of
methodologies irrelevant. For example, D and Rust appear almost identical in
terms of modularity (``Language Contributions to Program Modularity''),
portability (``Portability of a Language''), I/O facilities (``Input/Output''),
and support for inline assembly and foreign functions (``Escape from a
Language''). These methodologies either contribute little to my goal of
studying the memory safety of Rust and D, or the features provided by each
language are so similar that there is little comparison to be made between the
two.

\section{Experimental Design}

While I believe that the aforementioned methodologies comprise a satisfactory
qualitative evaluation strategy for Rust and D, I do not believe that a full
comparison can be achieved with these methodologies alone. Furthermore, many of
the criteria are rather subjective. For my project, I have strived to develop a
method which can be used to compare various language features while avoiding
subjectivity or bias.

Originally, I planned to come up with a number of programs that embodied the
core of systems programming, and then develop these programs in C++, D, and
Rust. Then, using my own experiences, I would attempt to evaluate the
effectiveness of each language for developing these programs. However, this
approach is flawed in a number of ways. For example, suppose I had attempted to
implement a program with logic that required a large amount of conditionals in
Rust. I would likely have encountered a number of bugs with my initial
implementation but eventually have come up with a satisfactory result. Then,
upon moving onto D, I would have avoided most of the errors that I encountered
while working on the Rust implementation. My development process in D would
likely have felt more natural, and the code would probably look eerily like
Rust. To mitigate this problem, I instead recruited a number of volunteers to
learn each language individually, and implement a series of programs meant to
demonstrate various features that are important to systems languages.

I advertised my study both on the Computer Science Facebook group and through
Computer Science colloquium. Once volunteers indicated their interest, I sent
them a document\footnote{The document may be found in
Appendix~\ref{app:resources}.} detailing my expectations for the project. The
volunteers then sent me information including their name, major, experience
with programming, and a confirmation that they read the document in its
entirety.

The document contained resources for installing and using the languages. In
order to reduce bias introduced by outside resources, I limited the resources
available to each volunteer to the language reference and an additional book.
Using websites such as StackOverflow was explicitly disallowed. I also
disallowed installing autocomplete packages or IDEs.

Each volunteer was then assigned either Rust or D as a language. I tried to
satisfy the volunteer's preference for which language to learn, though I first
ensured that the experience level between each language would be comparable.
Over the next month, each volunteer was expected to attempt to implement one of
five programs. The volunteers were not expected to spend more than 2 hours on
each program, but most volunteers who finished worked on each program to
completion.

The programs implemented by the volunteers were designed to cover an
assortment of language features as well as to highlight common bugs. The
programs were as follows:

\begin{enumerate}

\item Sentence Splitter

Volunteers were asked to implement a single string into sentences using a set
of heuristics. The difficulty of this program stems from the fact that
while sentences are delimited by periods, question marks, and exclamation
points, they may also include websites, titles, and abbreviations, all of
which are \textit{not} boundaries.

This program was meant to introduce the programmers to string manipulation
techniques and required a large amount of logical branching.

\item Integer Linked List

The next program was to implement a simple linked list data structure that
operates on integers. A number of operations were required to be supported,
including insertion, deletion, retrieval, and methods to query the size, head
and tail of the list.

This program introduced the volunteers to object-orientation, pointer
manipulation, and memory allocation.

\item Generic Array List

The next program involved creating an array list that supported generic
elements. The array list was required to support the same operations as the
integer linked list, and covered the same features of the languages.

\item Parallel Mergesort

Volunteers were then asked to implement the parallel mergesort algorithm. This
algorithm is relatively simple to understand, and easily parallelizable.

This program introduced the programmers to recursion and concurrency.

\item Brainfuck Interpreter

Lastly, the programmers were asked to implement a Brainfuck interpreter.
Brainfuck is an esoteric programming language, known for being fiendishly
unreadable. However, the language's semantics are quite easy to understand. In
short, there are eight meaningful characters in the language, all of which
either manipulate the ``data pointer'' in some way (by incrementing,
decrementing, etc.), or perform I/O on the byte pointed at by the pointer.

This program served as a kind of ``capstone'' for the study. It is larger than
the other programs, and involves file I/O and pointer manipulation.

\end{enumerate}

Each volunteer was also required to document their development process. While
developing each program, the volunteer would note every error encountered,
categorize it as a syntax error, logic error, or resource error, and whether
the error was caught at compile-time or run-time.

\chapter{Results}

Given Rust's focus on compile-time error catching and D's focus on ease of
use, I hypothesized that my volunteers would encounter a much greater number
of compile time issues with Rust, and that D programmers would find that their
programs ran into more runtime issues. Also, D's syntax would be more familiar
to my volunteers. I found that my hypothesis was true.

\section{Experimental Results}

I was able to recruit seven volunteers that generously offered their time and
effort to my project. Each volunteer was very experienced in programming: six
were computer science majors, and one was a computer science minor.
Figure~\ref{fig:sampleerrorlog} contains a snippet of an error log submitted
by one of my volunteers.

\begin{figure}[h]
\begin{lstlisting}[breaklines]
Syntax error - Wrong syntax of println - Compile time
Syntax error - Wrote "splitSentences" instead of "split_sentences" - Compile time
Syntax error - Used old variable name - Compile time
Syntax error - Tried to iterate over len() instead of range(0, len()) - Compile time
Syntax error - Used one argument instead of two with range() - Compile time
Syntax error - Passed char instead of &char in the contains func - Compile time
Syntax error - Used [char] instead of &[char] in initialization of array - Compile time
\end{lstlisting}
\caption{Sample error log}
\label{fig:sampleerrorlog}
\end{figure}

Unfortunately, due to time constraints, many volunteers were unable to follow
through with the entire study. I have obtained results from those who were
able to attempt each program, though by the fourth program I only had
volunteers who were writing D left.

All of my volunteers were able to complete the sentence splitter. It was very
interesting to see the types of errors that were encountered during this phase
of the experiment, as it was the volunteers' first introduction to the
language. As expected, Rust programmers found many more compile time issues.
Somewhat surprisingly, D programmers ran into segmentation faults due to the
behavior of attempting to access iterators out of bounds, while Rust
programmers simply encountered panics\footnote{Similar to an uncaught
exception.}. Though this program required no advanced language features, there
was a fair amount of difficultly in ensuring that arrays were not accessed
invalidly. The errors are summarized in Table~\ref{tab:sentencesplitter}.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
A (D) & 6 & 2 & 0 & Does not compile \\
B (Rust) & 6 & 0 & 0 & Did not finish \\
C (D) & 8 & 2 & 0 & Passes test suite \\
D (D) & 2 & 1 & 0 & Infinite loop on ellipsis \\
E (Rust) & 18 & 5 & 0 & Passes test suite \\
F (Rust) & 15 & 0 & 0 & Passes test suite \\
G (D) & 4 & 2 & 0 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Sentence splitter error log summary}
\label{tab:sentencesplitter}
\end{table}

Four volunteers attempted the integer linked list. Volunteer B was
particularly frustrated by this assignment, as it was extremely difficult to
implement a true linked list in Rust without resorting to language facilities
guarded by the \texttt{unsafe} keyword. While it is not discouraged to use
such features, for a beginner they are understandably intimidating. The
results from this program are located in Table~\ref{tab:intlinkedlist}.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
B (Rust) & 10 & 0 & 0 & Did not finish \\
C (D) & 9 & 0 & 1 & Passes test suite \\
D (D) & 1 & 0 & 3 & Segfault on \texttt{remove()} \\
G (D) & 6 & 1 & 2 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Integer linked list error log summary}
\label{tab:intlinkedlist}
\end{table}

The generic array list was easier due to only requiring the ownership of a
single pointer. However, this program was also difficult to implement in Rust
due to requiring dynamic allocation of memory. There is currently no safe way
to allocate an array of a generic type, so the only way to complete the program
without resorting to unsafe allocation is to use \texttt{Vec}, which is a
dynamic array in itself. This might be considered against the spirit of the
exercise.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
B (Rust) & 1 & 0 & 0 & Did not finish \\
D (D) & 2 & 0 & 0 & Passes test suite \\
G (D) & 4 & 0 & 0 & Passes, \texttt{head()} and \texttt{tail()} not implemented \\
\bottomrule
\end{tabular}
\caption{Generic array list error log summary}
\label{tab:genericarraylist}
\end{table}

Unfortunately, at this point in the study I no longer had any volunteers on
the Rust side. However, the D volunteers had little trouble implementing the
mergesort algorithm. Surprisingly, this ended up being the easiest task to
implement.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
D (D) & 3 & 1 & 0 & Passes test suite \\
G (D) & 3 & 2 & 0 & Passes test suite \\
\bottomrule
\end{tabular}
\caption{Parallel mergesort error log summary}
\label{tab:parallelmergesort}
\end{table}

No volunteer was able to correctly implement the brainfuck interpreter. Both
programs either output garbage or triggered a segmentation fault.

\begin{table}[h]
\centering
\begin{tabular}{lrrrp{5cm}}
\toprule
Volunteer & Syntax & Logic & Resource & Notes \\
\midrule
D (D) & 9 & 0 & 0 & Segmentation fault \\
G (D) & 4 & 1 & 0 & Fails test suite \\
\bottomrule
\end{tabular}
\caption{Brainfuck interpreter error log summary}
\label{tab:brainfuckinterpreter}
\end{table}

\section{Discussion}

Based on my own experiences with the implementation of my programs, and the
experiences of the volunteers of my study, I have assessed both Rust and D as
productive languages. I explore the strengths and weaknesses of both languages
through the context of each of the programs.

Since the error logs are self reported, it would not be productive to form an
analysis based on the numbers themselves. However, it is possible to observe
some overall trends, and draw conclusions based upon those trends and my own
experiences with the implementation of the programs of my study.

For the sentence splitter, the algorithm that I chose to implement for my
solution depends on manipulating a pointer to the string of data that contains
the paragraph to split. Due to the pointer manipulation, it was easier to use D
for this algorithm. However, it was very easy to encounter range violations in
D, which is a runtime error. Since my Rust implementation used Rust's
iterators, it was easy to verify that I wasn't iterating over the same
characters multiple times.

The data structures offered some very interesting data. Rust in particular
offered some real challenges. I sympathize with the Rust volunteer who
struggled with implementing the linked list. Though Rust does offer the
programmer the ability to venture into memory unsafe territory, it is hard for
a beginner to determine when this is the correct choice. While Rust is
permissive enough to allow this, it was surprising that such a common
operation as allocating memory would need to resort to unsafe code.

The Rust volunteer that completed these structures was very frustrated by the
generic array list as well. This is due to the fact that it is very difficult
to implement these structure without resorting to \texttt{unsafe} facilities of
the language. Thankfully, Rust provides dynamic arrays and linked lists in the
standard library, but I imagine that it would be very difficult to implement
data structures that require pointer manipulation or cycles as a beginner,
which is to the language's detriment.

The parallel mergesort was an especially successful exercise. Both volunteers
were able to complete it, and the errors that they encountered were indicative
of the problems that are difficult to avoid in D. Most of the errors
encountered were syntax errors, but the logic errors that arose were range
violations, which were particular to D. However, I expect that if more Rust
volunteers had completed this program I would have encountered a similar
distribution of off-by-one errors in vector accesses.

I was surprised with the results of the Brainfuck interpreter. Each volunteer
completed the program, but the programs were not correct. The ``Hello World''
program used to test the interpreters was meant to expose bugs in
interpreters, so perhaps the programs worked as expected on simpler inputs.
This example did not expose any particular differences between the languages,
as I had a similar experience in implementing the interpreter in both
languages.

Overall, it was interesting to see how beginners approached the languages
differently. While some volunteers embraced the idioms of the new languages,
some volunteers attempted to code Java- or C++-like code, which could have
hindered them.

As for the study itself, there were a few things that I would have changed. I
was disappointed with the attrition of volunteers that the study suffered as
the semester got busier. Other studies have permitted volunteers to leave tasks
unfinished~\cite{Hoppe:2013:DBG:2509136.2509528}, but these studies had a much
larger sample size and longer time frame. In a survey that I distributed after
the study, some volunteers expressed that they would have appreciated more
direction in their objectives. I originally wanted to give the volunteers as
much freedom as possible in their schedule, but this made it difficult for some
to stay on track.

One volunteer suggested that I hold ``lab sessions'', or scheduled a specific
time and place for the volunteers to work on each program. I think that this
would have been beneficial in helping the volunteers stay on schedule, as well
as allowing me to more closely monitor the error logging process. However, this
might have introduced additional overhead to resolve the volunteers' schedules.
Another volunteer proposed that more starter code be given out, as this would
cut down on the implementation time for each task.

The volunteers generally liked the languages they were assigned and would be
inclined to use them for personal projects. The reception towards D was warmer
due to its similarity to C++ and Java, languages with which my volunteers were
more familiar.

\section{Evaluation}

Both D and Rust are improvements over C++. The increased power of their
respective type systems, lack of required manual memory management, and
compile-time features are attractive enough to warrant creating new programs
in these languages. However, I believe that they occupy different needs.

D definitely achieves its historical goal of being an easier-to-use C++. Its
syntax obviates the need for many tedious-to-write constructs in C++. Less
syntax generally meant more readable code. However, I found the unhelpful error
messages a hindrance to development. I often had to open \texttt{gdb} to debug
segmentation faults and range violations, which, in addition to being runtime
errors, did not give line numbers in their error messages. If I needed to
develop a fast prototype, I would consider using D.

This goes along with the fact that D is generally more permissive than Rust. D
will let you write more constructs that could lead to runtime issues. This
permissiveness is also is seen in the languages' policies towards mutability.
While D programmers must opt into immutability by using the \texttt{const} or
\texttt{immutable} keyword, Rust programmers must opt into \textit{mutability}
by using the \texttt{mut} keyword. There are a number of optimization
opportunities that are available to the compiler with immutable data, and the
fact that Rust encourages immutability improves the chances that these
optimizations can be made. It also forces the programmer to think about whether
variables actually need to be mutable. Though Rust is less permissive in this
regard, I think it is a huge boon to the language.

As a beginner I found it very difficult to rapidly develop programs in Rust.
However, the error messages were far more helpful than D, and the compiler
disallowed constructs that I originally attempted because they were
error-prone. I also found its syntax more readable. Not only are parentheses
optional around expressions in block statements, the compiler actually emits a
warning if they are present. This, along with other lint warnings emitted by
the compiler ensure that Rust code has a consistent, readable style which
contributes to the readability of arbitrary Rust code seen for the first time.

I believe that both D and Rust have the potential to displace C++ as a systems
language of choice. Rust is perhaps more useful for safety-critical
applications, while D would be more useful for rapid development.

\chapter{Conclusion}

In this paper I have discussed and evaluated the D and Rust programming
languages with a focus on productivity for beginners. I believe that both
languages accomplish their design goals: D to make a more ergonomic C++, and
Rust to bring memory safety to the forefront of a programmer's thought process.

I examined the history and design philosophies of both languages and compared
features that highlighted the deficiencies of C++ as a productive, safe
language. I found that both D and Rust had sensible and useful alternatives to
the C++ feature under scrutiny.

I also performed a user study to examine how experienced C++ programmers
used the new languages. My study, though suffering from a lack of data,
confirmed my hypothesis that D would be easier to learn and develop into,
though Rust would assist the programmers in avoiding bugs.

There are many factors that determine what the true ``successor'' of C++ will
be. Considering the amount of legacy code in production today, I doubt that C++
will ever be truly succeeded. However, I am confident that both D and Rust have
their place in software development in the future.

\nocite{*}
\bibliography{senior-project}

\appendix \chapter{Volunteer Resources}\label{app:resources} The following
documents were sent to the volunteers of my project. The documents contain
explanations of the project expectations, brief descriptions of the programs to
be implemented, resources, and installation instructions for the languages
themselves.

The documents were written using Markdown. The versions included in this
appendix are rendered from \LaTeX{} generated from the Markdown source. The
documents appear online at
\url{https://github.com/euclio/senior-project/tree/master/resources}.

\clearpage
\input{../resources/project_agreement.tex}
\clearpage
\input{../resources/d_resources.tex}
\clearpage
\input{../resources/rust_resources.tex}

\chapter{Solutions}\label{app:solutions}
This appendix includes my solutions to the problems that were given to my
volunteers. The code in each example strives to be as idiomatic as possible in
each language.

\clearpage

\setminted{bgcolor=}

\section{Hello, World}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted{cpp}{../examples/hello-world/hello_world.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted{d}{../examples/hello-world/hello_world.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted{rust}{../examples/hello-world/hello_world.rs}
\end{mdframed}

\section{Sentence Splitter}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/sentence-splitter/sentence_splitter.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/sentence-splitter/sentence_splitter.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/sentence-splitter/sentence_splitter.rs}
\end{mdframed}

\section{Integer Linked List}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/int-linked-list/int_linked_list.hpp}
\end{mdframed}

\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/int-linked-list/int_linked_list.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/int-linked-list/int_linked_list.d}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/int-linked-list/tests/int-linked-list-test.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/int-linked-list/int_linked_list.rs}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/int-linked-list/tests/int-linked-list-test.rs}
\end{mdframed}

\section{Generic Array List}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/generic-array-list/generic_array_list.hpp}
\end{mdframed}

\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/generic-array-list/generic_array_list.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/generic-array-list/generic_array_list.d}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/generic-array-list/tests/generic_array_list_test.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/generic-array-list/generic_array_list.rs}
\end{mdframed}

\subsubsection{Test Case}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/generic-array-list/tests/generic-array-list-test.rs}
\end{mdframed}

\section{Parallel Merge Sort}
\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/parallel-merge-sort/parallel_merge_sort.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/parallel-merge-sort/parallel_merge_sort.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/parallel-merge-sort/parallel_merge_sort.rs}
\end{mdframed}

\section{Brainfuck Interpreter}

\subsection{C++}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{cpp}{../examples/brainfsck/brainfsck.cpp}
\end{mdframed}

\subsection{D}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{d}{../examples/brainfsck/brainfsck.d}
\end{mdframed}

\subsection{Rust}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{rust}{../examples/brainfsck/brainfsck.rs}
\end{mdframed}

\subsection{Brainfuck Test Case (``Hello World'')}
\begin{mdframed}[linecolor=black]
\inputminted[fontsize=\scriptsize]{brainfuck}{../examples/brainfsck/tests/hello.bf}
\end{mdframed}

\end{document}
